// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comm.proto

#ifndef PROTOBUF_comm_2eproto__INCLUDED
#define PROTOBUF_comm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_comm_2eproto();
void protobuf_AssignDesc_comm_2eproto();
void protobuf_ShutdownFile_comm_2eproto();

class Finger;
class NameSpace;
class LoginInfo;
class Point;
class ManipulateNS;
class QueryDocument;
class NameValueSet;
class Document;
class Header;
class Payload;
class PayloadReply;
class Request;
class Response;
class Heartbeat;
class Network;
class Management;

enum NameValueSet_NodeType {
  NameValueSet_NodeType_NODE = 1,
  NameValueSet_NodeType_VALUE = 2
};
bool NameValueSet_NodeType_IsValid(int value);
const NameValueSet_NodeType NameValueSet_NodeType_NodeType_MIN = NameValueSet_NodeType_NODE;
const NameValueSet_NodeType NameValueSet_NodeType_NodeType_MAX = NameValueSet_NodeType_VALUE;
const int NameValueSet_NodeType_NodeType_ARRAYSIZE = NameValueSet_NodeType_NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NameValueSet_NodeType_descriptor();
inline const ::std::string& NameValueSet_NodeType_Name(NameValueSet_NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NameValueSet_NodeType_descriptor(), value);
}
inline bool NameValueSet_NodeType_Parse(
    const ::std::string& name, NameValueSet_NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NameValueSet_NodeType>(
    NameValueSet_NodeType_descriptor(), name, value);
}
enum Header_Routing {
  Header_Routing_FINGER = 2,
  Header_Routing_STATS = 3,
  Header_Routing_LOGIN = 10,
  Header_Routing_NAMESPACEADD = 11,
  Header_Routing_NAMESPACEFIND = 12,
  Header_Routing_NAMESPACEREMOVE = 13,
  Header_Routing_LOGINJPA = 15,
  Header_Routing_NAMESPACEADDJPA = 16,
  Header_Routing_NAMESPACEFINDJPA = 17,
  Header_Routing_NAMESPACEREMOVEJPA = 18,
  Header_Routing_DOCADD = 20,
  Header_Routing_DOCFIND = 21,
  Header_Routing_DOCUPDATE = 22,
  Header_Routing_DOCREMOVE = 23
};
bool Header_Routing_IsValid(int value);
const Header_Routing Header_Routing_Routing_MIN = Header_Routing_FINGER;
const Header_Routing Header_Routing_Routing_MAX = Header_Routing_DOCREMOVE;
const int Header_Routing_Routing_ARRAYSIZE = Header_Routing_Routing_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_Routing_descriptor();
inline const ::std::string& Header_Routing_Name(Header_Routing value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_Routing_descriptor(), value);
}
inline bool Header_Routing_Parse(
    const ::std::string& name, Header_Routing* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_Routing>(
    Header_Routing_descriptor(), name, value);
}
enum Header_ReplyStatus {
  Header_ReplyStatus_SUCCESS = 1,
  Header_ReplyStatus_FAILURE = 2,
  Header_ReplyStatus_NOAUTH = 3,
  Header_ReplyStatus_MISSINGARG = 4,
  Header_ReplyStatus_NOCONNECTION = 5
};
bool Header_ReplyStatus_IsValid(int value);
const Header_ReplyStatus Header_ReplyStatus_ReplyStatus_MIN = Header_ReplyStatus_SUCCESS;
const Header_ReplyStatus Header_ReplyStatus_ReplyStatus_MAX = Header_ReplyStatus_NOCONNECTION;
const int Header_ReplyStatus_ReplyStatus_ARRAYSIZE = Header_ReplyStatus_ReplyStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_ReplyStatus_descriptor();
inline const ::std::string& Header_ReplyStatus_Name(Header_ReplyStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_ReplyStatus_descriptor(), value);
}
inline bool Header_ReplyStatus_Parse(
    const ::std::string& name, Header_ReplyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_ReplyStatus>(
    Header_ReplyStatus_descriptor(), name, value);
}
enum Network_Action {
  Network_Action_NODEJOIN = 1,
  Network_Action_NODELEAVE = 2,
  Network_Action_NODEDEAD = 3,
  Network_Action_MAP = 55,
  Network_Action_ANNOUNCE = 56,
  Network_Action_SHUTDOWN = 999
};
bool Network_Action_IsValid(int value);
const Network_Action Network_Action_Action_MIN = Network_Action_NODEJOIN;
const Network_Action Network_Action_Action_MAX = Network_Action_SHUTDOWN;
const int Network_Action_Action_ARRAYSIZE = Network_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* Network_Action_descriptor();
inline const ::std::string& Network_Action_Name(Network_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    Network_Action_descriptor(), value);
}
inline bool Network_Action_Parse(
    const ::std::string& name, Network_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Network_Action>(
    Network_Action_descriptor(), name, value);
}
// ===================================================================

class Finger : public ::google::protobuf::Message {
 public:
  Finger();
  virtual ~Finger();
  
  Finger(const Finger& from);
  
  inline Finger& operator=(const Finger& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Finger& default_instance();
  
  void Swap(Finger* other);
  
  // implements Message ----------------------------------------------
  
  Finger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Finger& from);
  void MergeFrom(const Finger& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // required string tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // @@protoc_insertion_point(class_scope:Finger)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_tag();
  inline void clear_has_tag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* tag_;
  ::google::protobuf::int32 number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Finger* default_instance_;
};
// -------------------------------------------------------------------

class NameSpace : public ::google::protobuf::Message {
 public:
  NameSpace();
  virtual ~NameSpace();
  
  NameSpace(const NameSpace& from);
  
  inline NameSpace& operator=(const NameSpace& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NameSpace& default_instance();
  
  void Swap(NameSpace* other);
  
  // implements Message ----------------------------------------------
  
  NameSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameSpace& from);
  void MergeFrom(const NameSpace& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string city = 3;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 3;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  
  // required string zip_code = 4;
  inline bool has_zip_code() const;
  inline void clear_zip_code();
  static const int kZipCodeFieldNumber = 4;
  inline const ::std::string& zip_code() const;
  inline void set_zip_code(const ::std::string& value);
  inline void set_zip_code(const char* value);
  inline void set_zip_code(const char* value, size_t size);
  inline ::std::string* mutable_zip_code();
  inline ::std::string* release_zip_code();
  
  // required string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:NameSpace)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_zip_code();
  inline void clear_has_zip_code();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_id_;
  ::std::string* name_;
  ::std::string* city_;
  ::std::string* zip_code_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static NameSpace* default_instance_;
};
// -------------------------------------------------------------------

class LoginInfo : public ::google::protobuf::Message {
 public:
  LoginInfo();
  virtual ~LoginInfo();
  
  LoginInfo(const LoginInfo& from);
  
  inline LoginInfo& operator=(const LoginInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginInfo& default_instance();
  
  void Swap(LoginInfo* other);
  
  // implements Message ----------------------------------------------
  
  LoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginInfo& from);
  void MergeFrom(const LoginInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:LoginInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_id_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static LoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();
  
  Point(const Point& from);
  
  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();
  
  void Swap(Point* other);
  
  // implements Message ----------------------------------------------
  
  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);
  
  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);
  
  // @@protoc_insertion_point(class_scope:Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double x_;
  double y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class ManipulateNS : public ::google::protobuf::Message {
 public:
  ManipulateNS();
  virtual ~ManipulateNS();
  
  ManipulateNS(const ManipulateNS& from);
  
  inline ManipulateNS& operator=(const ManipulateNS& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ManipulateNS& default_instance();
  
  void Swap(ManipulateNS* other);
  
  // implements Message ----------------------------------------------
  
  ManipulateNS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManipulateNS& from);
  void MergeFrom(const ManipulateNS& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string city = 3;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 3;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  
  // optional string zip_code = 4;
  inline bool has_zip_code() const;
  inline void clear_zip_code();
  static const int kZipCodeFieldNumber = 4;
  inline const ::std::string& zip_code() const;
  inline void set_zip_code(const ::std::string& value);
  inline void set_zip_code(const char* value);
  inline void set_zip_code(const char* value, size_t size);
  inline ::std::string* mutable_zip_code();
  inline ::std::string* release_zip_code();
  
  // @@protoc_insertion_point(class_scope:ManipulateNS)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_zip_code();
  inline void clear_has_zip_code();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_id_;
  ::std::string* name_;
  ::std::string* city_;
  ::std::string* zip_code_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static ManipulateNS* default_instance_;
};
// -------------------------------------------------------------------

class QueryDocument : public ::google::protobuf::Message {
 public:
  QueryDocument();
  virtual ~QueryDocument();
  
  QueryDocument(const QueryDocument& from);
  
  inline QueryDocument& operator=(const QueryDocument& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryDocument& default_instance();
  
  void Swap(QueryDocument* other);
  
  // implements Message ----------------------------------------------
  
  QueryDocument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryDocument& from);
  void MergeFrom(const QueryDocument& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  
  // optional .Point location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::Point& location() const;
  inline ::Point* mutable_location();
  inline ::Point* release_location();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:QueryDocument)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_id_;
  ::Point* location_;
  ::std::string* name_;
  ::google::protobuf::int64 time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static QueryDocument* default_instance_;
};
// -------------------------------------------------------------------

class NameValueSet : public ::google::protobuf::Message {
 public:
  NameValueSet();
  virtual ~NameValueSet();
  
  NameValueSet(const NameValueSet& from);
  
  inline NameValueSet& operator=(const NameValueSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NameValueSet& default_instance();
  
  void Swap(NameValueSet* other);
  
  // implements Message ----------------------------------------------
  
  NameValueSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameValueSet& from);
  void MergeFrom(const NameValueSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef NameValueSet_NodeType NodeType;
  static const NodeType NODE = NameValueSet_NodeType_NODE;
  static const NodeType VALUE = NameValueSet_NodeType_VALUE;
  static inline bool NodeType_IsValid(int value) {
    return NameValueSet_NodeType_IsValid(value);
  }
  static const NodeType NodeType_MIN =
    NameValueSet_NodeType_NodeType_MIN;
  static const NodeType NodeType_MAX =
    NameValueSet_NodeType_NodeType_MAX;
  static const int NodeType_ARRAYSIZE =
    NameValueSet_NodeType_NodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeType_descriptor() {
    return NameValueSet_NodeType_descriptor();
  }
  static inline const ::std::string& NodeType_Name(NodeType value) {
    return NameValueSet_NodeType_Name(value);
  }
  static inline bool NodeType_Parse(const ::std::string& name,
      NodeType* value) {
    return NameValueSet_NodeType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .NameValueSet.NodeType node_type = 1;
  inline bool has_node_type() const;
  inline void clear_node_type();
  static const int kNodeTypeFieldNumber = 1;
  inline ::NameValueSet_NodeType node_type() const;
  inline void set_node_type(::NameValueSet_NodeType value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // repeated .NameValueSet node = 4;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 4;
  inline const ::NameValueSet& node(int index) const;
  inline ::NameValueSet* mutable_node(int index);
  inline ::NameValueSet* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
      mutable_node();
  
  // @@protoc_insertion_point(class_scope:NameValueSet)
 private:
  inline void set_has_node_type();
  inline void clear_has_node_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* value_;
  ::google::protobuf::RepeatedPtrField< ::NameValueSet > node_;
  int node_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static NameValueSet* default_instance_;
};
// -------------------------------------------------------------------

class Document : public ::google::protobuf::Message {
 public:
  Document();
  virtual ~Document();
  
  Document(const Document& from);
  
  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Document& default_instance();
  
  void Swap(Document* other);
  
  // implements Message ----------------------------------------------
  
  Document* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Document& from);
  void MergeFrom(const Document& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name_space = 1;
  inline bool has_name_space() const;
  inline void clear_name_space();
  static const int kNameSpaceFieldNumber = 1;
  inline const ::std::string& name_space() const;
  inline void set_name_space(const ::std::string& value);
  inline void set_name_space(const char* value);
  inline void set_name_space(const char* value, size_t size);
  inline ::std::string* mutable_name_space();
  inline ::std::string* release_name_space();
  
  // optional int64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // required bytes img_byte = 3;
  inline bool has_img_byte() const;
  inline void clear_img_byte();
  static const int kImgByteFieldNumber = 3;
  inline const ::std::string& img_byte() const;
  inline void set_img_byte(const ::std::string& value);
  inline void set_img_byte(const char* value);
  inline void set_img_byte(const void* value, size_t size);
  inline ::std::string* mutable_img_byte();
  inline ::std::string* release_img_byte();
  
  // required .Point location = 4;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::Point& location() const;
  inline ::Point* mutable_location();
  inline ::Point* release_location();
  
  // optional string file_name = 5;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 5;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // optional string file_type = 6;
  inline bool has_file_type() const;
  inline void clear_file_type();
  static const int kFileTypeFieldNumber = 6;
  inline const ::std::string& file_type() const;
  inline void set_file_type(const ::std::string& value);
  inline void set_file_type(const char* value);
  inline void set_file_type(const char* value, size_t size);
  inline ::std::string* mutable_file_type();
  inline ::std::string* release_file_type();
  
  // optional int64 time = 7;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 7;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:Document)
 private:
  inline void set_has_name_space();
  inline void clear_has_name_space();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_img_byte();
  inline void clear_has_img_byte();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_type();
  inline void clear_has_file_type();
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_space_;
  ::google::protobuf::int64 id_;
  ::std::string* img_byte_;
  ::Point* location_;
  ::std::string* file_name_;
  ::std::string* file_type_;
  ::google::protobuf::int64 time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Document* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();
  
  Header(const Header& from);
  
  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();
  
  void Swap(Header* other);
  
  // implements Message ----------------------------------------------
  
  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Header_Routing Routing;
  static const Routing FINGER = Header_Routing_FINGER;
  static const Routing STATS = Header_Routing_STATS;
  static const Routing LOGIN = Header_Routing_LOGIN;
  static const Routing NAMESPACEADD = Header_Routing_NAMESPACEADD;
  static const Routing NAMESPACEFIND = Header_Routing_NAMESPACEFIND;
  static const Routing NAMESPACEREMOVE = Header_Routing_NAMESPACEREMOVE;
  static const Routing LOGINJPA = Header_Routing_LOGINJPA;
  static const Routing NAMESPACEADDJPA = Header_Routing_NAMESPACEADDJPA;
  static const Routing NAMESPACEFINDJPA = Header_Routing_NAMESPACEFINDJPA;
  static const Routing NAMESPACEREMOVEJPA = Header_Routing_NAMESPACEREMOVEJPA;
  static const Routing DOCADD = Header_Routing_DOCADD;
  static const Routing DOCFIND = Header_Routing_DOCFIND;
  static const Routing DOCUPDATE = Header_Routing_DOCUPDATE;
  static const Routing DOCREMOVE = Header_Routing_DOCREMOVE;
  static inline bool Routing_IsValid(int value) {
    return Header_Routing_IsValid(value);
  }
  static const Routing Routing_MIN =
    Header_Routing_Routing_MIN;
  static const Routing Routing_MAX =
    Header_Routing_Routing_MAX;
  static const int Routing_ARRAYSIZE =
    Header_Routing_Routing_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Routing_descriptor() {
    return Header_Routing_descriptor();
  }
  static inline const ::std::string& Routing_Name(Routing value) {
    return Header_Routing_Name(value);
  }
  static inline bool Routing_Parse(const ::std::string& name,
      Routing* value) {
    return Header_Routing_Parse(name, value);
  }
  
  typedef Header_ReplyStatus ReplyStatus;
  static const ReplyStatus SUCCESS = Header_ReplyStatus_SUCCESS;
  static const ReplyStatus FAILURE = Header_ReplyStatus_FAILURE;
  static const ReplyStatus NOAUTH = Header_ReplyStatus_NOAUTH;
  static const ReplyStatus MISSINGARG = Header_ReplyStatus_MISSINGARG;
  static const ReplyStatus NOCONNECTION = Header_ReplyStatus_NOCONNECTION;
  static inline bool ReplyStatus_IsValid(int value) {
    return Header_ReplyStatus_IsValid(value);
  }
  static const ReplyStatus ReplyStatus_MIN =
    Header_ReplyStatus_ReplyStatus_MIN;
  static const ReplyStatus ReplyStatus_MAX =
    Header_ReplyStatus_ReplyStatus_MAX;
  static const int ReplyStatus_ARRAYSIZE =
    Header_ReplyStatus_ReplyStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReplyStatus_descriptor() {
    return Header_ReplyStatus_descriptor();
  }
  static inline const ::std::string& ReplyStatus_Name(ReplyStatus value) {
    return Header_ReplyStatus_Name(value);
  }
  static inline bool ReplyStatus_Parse(const ::std::string& name,
      ReplyStatus* value) {
    return Header_ReplyStatus_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Header.Routing routing_id = 2;
  inline bool has_routing_id() const;
  inline void clear_routing_id();
  static const int kRoutingIdFieldNumber = 2;
  inline ::Header_Routing routing_id() const;
  inline void set_routing_id(::Header_Routing value);
  
  // required string originator = 3;
  inline bool has_originator() const;
  inline void clear_originator();
  static const int kOriginatorFieldNumber = 3;
  inline const ::std::string& originator() const;
  inline void set_originator(const ::std::string& value);
  inline void set_originator(const char* value);
  inline void set_originator(const char* value, size_t size);
  inline ::std::string* mutable_originator();
  inline ::std::string* release_originator();
  
  // required string tag = 4;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 4;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  
  // optional .Header.ReplyStatus reply_code = 5;
  inline bool has_reply_code() const;
  inline void clear_reply_code();
  static const int kReplyCodeFieldNumber = 5;
  inline ::Header_ReplyStatus reply_code() const;
  inline void set_reply_code(::Header_ReplyStatus value);
  
  // optional string reply_msg = 6;
  inline bool has_reply_msg() const;
  inline void clear_reply_msg();
  static const int kReplyMsgFieldNumber = 6;
  inline const ::std::string& reply_msg() const;
  inline void set_reply_msg(const ::std::string& value);
  inline void set_reply_msg(const char* value);
  inline void set_reply_msg(const char* value, size_t size);
  inline ::std::string* mutable_reply_msg();
  inline ::std::string* release_reply_msg();
  
  // @@protoc_insertion_point(class_scope:Header)
 private:
  inline void set_has_routing_id();
  inline void clear_has_routing_id();
  inline void set_has_originator();
  inline void clear_has_originator();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_reply_code();
  inline void clear_has_reply_code();
  inline void set_has_reply_msg();
  inline void clear_has_reply_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* originator_;
  int routing_id_;
  int reply_code_;
  ::std::string* tag_;
  ::std::string* reply_msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Payload : public ::google::protobuf::Message {
 public:
  Payload();
  virtual ~Payload();
  
  Payload(const Payload& from);
  
  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Payload& default_instance();
  
  void Swap(Payload* other);
  
  // implements Message ----------------------------------------------
  
  Payload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Payload& from);
  void MergeFrom(const Payload& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Finger finger = 1;
  inline bool has_finger() const;
  inline void clear_finger();
  static const int kFingerFieldNumber = 1;
  inline const ::Finger& finger() const;
  inline ::Finger* mutable_finger();
  inline ::Finger* release_finger();
  
  // optional .Document doc = 2;
  inline bool has_doc() const;
  inline void clear_doc();
  static const int kDocFieldNumber = 2;
  inline const ::Document& doc() const;
  inline ::Document* mutable_doc();
  inline ::Document* release_doc();
  
  // optional .NameSpace space = 3;
  inline bool has_space() const;
  inline void clear_space();
  static const int kSpaceFieldNumber = 3;
  inline const ::NameSpace& space() const;
  inline ::NameSpace* mutable_space();
  inline ::NameSpace* release_space();
  
  // optional .QueryDocument query = 4;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 4;
  inline const ::QueryDocument& query() const;
  inline ::QueryDocument* mutable_query();
  inline ::QueryDocument* release_query();
  
  // optional .ManipulateNS queryUser = 5;
  inline bool has_queryuser() const;
  inline void clear_queryuser();
  static const int kQueryUserFieldNumber = 5;
  inline const ::ManipulateNS& queryuser() const;
  inline ::ManipulateNS* mutable_queryuser();
  inline ::ManipulateNS* release_queryuser();
  
  // optional .LoginInfo login = 6;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 6;
  inline const ::LoginInfo& login() const;
  inline ::LoginInfo* mutable_login();
  inline ::LoginInfo* release_login();
  
  // @@protoc_insertion_point(class_scope:Payload)
 private:
  inline void set_has_finger();
  inline void clear_has_finger();
  inline void set_has_doc();
  inline void clear_has_doc();
  inline void set_has_space();
  inline void clear_has_space();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_queryuser();
  inline void clear_has_queryuser();
  inline void set_has_login();
  inline void clear_has_login();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Finger* finger_;
  ::Document* doc_;
  ::NameSpace* space_;
  ::QueryDocument* query_;
  ::ManipulateNS* queryuser_;
  ::LoginInfo* login_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Payload* default_instance_;
};
// -------------------------------------------------------------------

class PayloadReply : public ::google::protobuf::Message {
 public:
  PayloadReply();
  virtual ~PayloadReply();
  
  PayloadReply(const PayloadReply& from);
  
  inline PayloadReply& operator=(const PayloadReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PayloadReply& default_instance();
  
  void Swap(PayloadReply* other);
  
  // implements Message ----------------------------------------------
  
  PayloadReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayloadReply& from);
  void MergeFrom(const PayloadReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Document docs = 1;
  inline int docs_size() const;
  inline void clear_docs();
  static const int kDocsFieldNumber = 1;
  inline const ::Document& docs(int index) const;
  inline ::Document* mutable_docs(int index);
  inline ::Document* add_docs();
  inline const ::google::protobuf::RepeatedPtrField< ::Document >&
      docs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Document >*
      mutable_docs();
  
  // repeated .NameSpace spaces = 2;
  inline int spaces_size() const;
  inline void clear_spaces();
  static const int kSpacesFieldNumber = 2;
  inline const ::NameSpace& spaces(int index) const;
  inline ::NameSpace* mutable_spaces(int index);
  inline ::NameSpace* add_spaces();
  inline const ::google::protobuf::RepeatedPtrField< ::NameSpace >&
      spaces() const;
  inline ::google::protobuf::RepeatedPtrField< ::NameSpace >*
      mutable_spaces();
  
  // optional .Document stats = 3;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 3;
  inline const ::Document& stats() const;
  inline ::Document* mutable_stats();
  inline ::Document* release_stats();
  
  // optional .Document finger = 4;
  inline bool has_finger() const;
  inline void clear_finger();
  static const int kFingerFieldNumber = 4;
  inline const ::Document& finger() const;
  inline ::Document* mutable_finger();
  inline ::Document* release_finger();
  
  // optional string uuid = 5;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 5;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  
  // @@protoc_insertion_point(class_scope:PayloadReply)
 private:
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_finger();
  inline void clear_has_finger();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Document > docs_;
  ::google::protobuf::RepeatedPtrField< ::NameSpace > spaces_;
  ::Document* stats_;
  ::Document* finger_;
  ::std::string* uuid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static PayloadReply* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::Header& header() const;
  inline ::Header* mutable_header();
  inline ::Header* release_header();
  
  // required .Payload body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::Payload& body() const;
  inline ::Payload* mutable_body();
  inline ::Payload* release_body();
  
  // @@protoc_insertion_point(class_scope:Request)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Header* header_;
  ::Payload* body_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();
  
  Response(const Response& from);
  
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();
  
  void Swap(Response* other);
  
  // implements Message ----------------------------------------------
  
  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::Header& header() const;
  inline ::Header* mutable_header();
  inline ::Header* release_header();
  
  // optional .PayloadReply body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::PayloadReply& body() const;
  inline ::PayloadReply* mutable_body();
  inline ::PayloadReply* release_body();
  
  // @@protoc_insertion_point(class_scope:Response)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Header* header_;
  ::PayloadReply* body_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::Message {
 public:
  Heartbeat();
  virtual ~Heartbeat();
  
  Heartbeat(const Heartbeat& from);
  
  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();
  
  void Swap(Heartbeat* other);
  
  // implements Message ----------------------------------------------
  
  Heartbeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string nodeId = 1;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const char* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  
  // required int64 timeRef = 2;
  inline bool has_timeref() const;
  inline void clear_timeref();
  static const int kTimeRefFieldNumber = 2;
  inline ::google::protobuf::int64 timeref() const;
  inline void set_timeref(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:Heartbeat)
 private:
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_timeref();
  inline void clear_has_timeref();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nodeid_;
  ::google::protobuf::int64 timeref_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Heartbeat* default_instance_;
};
// -------------------------------------------------------------------

class Network : public ::google::protobuf::Message {
 public:
  Network();
  virtual ~Network();
  
  Network(const Network& from);
  
  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Network& default_instance();
  
  void Swap(Network* other);
  
  // implements Message ----------------------------------------------
  
  Network* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Network& from);
  void MergeFrom(const Network& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Network_Action Action;
  static const Action NODEJOIN = Network_Action_NODEJOIN;
  static const Action NODELEAVE = Network_Action_NODELEAVE;
  static const Action NODEDEAD = Network_Action_NODEDEAD;
  static const Action MAP = Network_Action_MAP;
  static const Action ANNOUNCE = Network_Action_ANNOUNCE;
  static const Action SHUTDOWN = Network_Action_SHUTDOWN;
  static inline bool Action_IsValid(int value) {
    return Network_Action_IsValid(value);
  }
  static const Action Action_MIN =
    Network_Action_Action_MIN;
  static const Action Action_MAX =
    Network_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    Network_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return Network_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return Network_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return Network_Action_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string nodeId = 1;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& nodeid() const;
  inline void set_nodeid(const ::std::string& value);
  inline void set_nodeid(const char* value);
  inline void set_nodeid(const char* value, size_t size);
  inline ::std::string* mutable_nodeid();
  inline ::std::string* release_nodeid();
  
  // required .Network.Action action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline ::Network_Action action() const;
  inline void set_action(::Network_Action value);
  
  // @@protoc_insertion_point(class_scope:Network)
 private:
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_action();
  inline void clear_has_action();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nodeid_;
  int action_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Network* default_instance_;
};
// -------------------------------------------------------------------

class Management : public ::google::protobuf::Message {
 public:
  Management();
  virtual ~Management();
  
  Management(const Management& from);
  
  inline Management& operator=(const Management& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Management& default_instance();
  
  void Swap(Management* other);
  
  // implements Message ----------------------------------------------
  
  Management* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Management& from);
  void MergeFrom(const Management& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Network graph = 1;
  inline bool has_graph() const;
  inline void clear_graph();
  static const int kGraphFieldNumber = 1;
  inline const ::Network& graph() const;
  inline ::Network* mutable_graph();
  inline ::Network* release_graph();
  
  // optional .Heartbeat beat = 2;
  inline bool has_beat() const;
  inline void clear_beat();
  static const int kBeatFieldNumber = 2;
  inline const ::Heartbeat& beat() const;
  inline ::Heartbeat* mutable_beat();
  inline ::Heartbeat* release_beat();
  
  // @@protoc_insertion_point(class_scope:Management)
 private:
  inline void set_has_graph();
  inline void clear_has_graph();
  inline void set_has_beat();
  inline void clear_has_beat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Network* graph_;
  ::Heartbeat* beat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();
  
  void InitAsDefaultInstance();
  static Management* default_instance_;
};
// ===================================================================


// ===================================================================

// Finger

// required int32 number = 1;
inline bool Finger::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Finger::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Finger::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Finger::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 Finger::number() const {
  return number_;
}
inline void Finger::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// required string tag = 2;
inline bool Finger::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Finger::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Finger::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Finger::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Finger::tag() const {
  return *tag_;
}
inline void Finger::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Finger::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Finger::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Finger::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* Finger::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NameSpace

// required string user_id = 1;
inline bool NameSpace::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameSpace::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameSpace::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameSpace::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& NameSpace::user_id() const {
  return *user_id_;
}
inline void NameSpace::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void NameSpace::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void NameSpace::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpace::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* NameSpace::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool NameSpace::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameSpace::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameSpace::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameSpace::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameSpace::name() const {
  return *name_;
}
inline void NameSpace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameSpace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameSpace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameSpace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string city = 3;
inline bool NameSpace::has_city() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameSpace::set_has_city() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameSpace::clear_has_city() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameSpace::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& NameSpace::city() const {
  return *city_;
}
inline void NameSpace::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void NameSpace::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void NameSpace::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpace::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* NameSpace::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string zip_code = 4;
inline bool NameSpace::has_zip_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NameSpace::set_has_zip_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NameSpace::clear_has_zip_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NameSpace::clear_zip_code() {
  if (zip_code_ != &::google::protobuf::internal::kEmptyString) {
    zip_code_->clear();
  }
  clear_has_zip_code();
}
inline const ::std::string& NameSpace::zip_code() const {
  return *zip_code_;
}
inline void NameSpace::set_zip_code(const ::std::string& value) {
  set_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    zip_code_ = new ::std::string;
  }
  zip_code_->assign(value);
}
inline void NameSpace::set_zip_code(const char* value) {
  set_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    zip_code_ = new ::std::string;
  }
  zip_code_->assign(value);
}
inline void NameSpace::set_zip_code(const char* value, size_t size) {
  set_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    zip_code_ = new ::std::string;
  }
  zip_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpace::mutable_zip_code() {
  set_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    zip_code_ = new ::std::string;
  }
  return zip_code_;
}
inline ::std::string* NameSpace::release_zip_code() {
  clear_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zip_code_;
    zip_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 5;
inline bool NameSpace::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NameSpace::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NameSpace::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NameSpace::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& NameSpace::password() const {
  return *password_;
}
inline void NameSpace::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void NameSpace::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void NameSpace::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameSpace::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* NameSpace::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginInfo

// required string user_id = 1;
inline bool LoginInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginInfo::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& LoginInfo::user_id() const {
  return *user_id_;
}
inline void LoginInfo::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void LoginInfo::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void LoginInfo::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* LoginInfo::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 2;
inline bool LoginInfo::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginInfo::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginInfo::password() const {
  return *password_;
}
inline void LoginInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Point

// required double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// ManipulateNS

// optional string user_id = 1;
inline bool ManipulateNS::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManipulateNS::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManipulateNS::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManipulateNS::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& ManipulateNS::user_id() const {
  return *user_id_;
}
inline void ManipulateNS::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void ManipulateNS::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void ManipulateNS::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManipulateNS::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* ManipulateNS::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 2;
inline bool ManipulateNS::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManipulateNS::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManipulateNS::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManipulateNS::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ManipulateNS::name() const {
  return *name_;
}
inline void ManipulateNS::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ManipulateNS::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ManipulateNS::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManipulateNS::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ManipulateNS::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string city = 3;
inline bool ManipulateNS::has_city() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManipulateNS::set_has_city() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManipulateNS::clear_has_city() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManipulateNS::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& ManipulateNS::city() const {
  return *city_;
}
inline void ManipulateNS::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void ManipulateNS::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void ManipulateNS::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManipulateNS::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* ManipulateNS::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string zip_code = 4;
inline bool ManipulateNS::has_zip_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManipulateNS::set_has_zip_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManipulateNS::clear_has_zip_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManipulateNS::clear_zip_code() {
  if (zip_code_ != &::google::protobuf::internal::kEmptyString) {
    zip_code_->clear();
  }
  clear_has_zip_code();
}
inline const ::std::string& ManipulateNS::zip_code() const {
  return *zip_code_;
}
inline void ManipulateNS::set_zip_code(const ::std::string& value) {
  set_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    zip_code_ = new ::std::string;
  }
  zip_code_->assign(value);
}
inline void ManipulateNS::set_zip_code(const char* value) {
  set_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    zip_code_ = new ::std::string;
  }
  zip_code_->assign(value);
}
inline void ManipulateNS::set_zip_code(const char* value, size_t size) {
  set_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    zip_code_ = new ::std::string;
  }
  zip_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManipulateNS::mutable_zip_code() {
  set_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    zip_code_ = new ::std::string;
  }
  return zip_code_;
}
inline ::std::string* ManipulateNS::release_zip_code() {
  clear_has_zip_code();
  if (zip_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zip_code_;
    zip_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// QueryDocument

// optional string user_id = 1;
inline bool QueryDocument::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryDocument::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryDocument::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryDocument::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& QueryDocument::user_id() const {
  return *user_id_;
}
inline void QueryDocument::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void QueryDocument::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void QueryDocument::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryDocument::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* QueryDocument::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Point location = 2;
inline bool QueryDocument::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryDocument::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryDocument::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryDocument::clear_location() {
  if (location_ != NULL) location_->::Point::Clear();
  clear_has_location();
}
inline const ::Point& QueryDocument::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Point* QueryDocument::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::Point;
  return location_;
}
inline ::Point* QueryDocument::release_location() {
  clear_has_location();
  ::Point* temp = location_;
  location_ = NULL;
  return temp;
}

// optional string name = 3;
inline bool QueryDocument::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryDocument::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryDocument::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryDocument::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& QueryDocument::name() const {
  return *name_;
}
inline void QueryDocument::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QueryDocument::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void QueryDocument::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryDocument::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* QueryDocument::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 time = 4;
inline bool QueryDocument::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryDocument::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryDocument::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryDocument::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 QueryDocument::time() const {
  return time_;
}
inline void QueryDocument::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// NameValueSet

// required .NameValueSet.NodeType node_type = 1;
inline bool NameValueSet::has_node_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameValueSet::set_has_node_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameValueSet::clear_has_node_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameValueSet::clear_node_type() {
  node_type_ = 1;
  clear_has_node_type();
}
inline ::NameValueSet_NodeType NameValueSet::node_type() const {
  return static_cast< ::NameValueSet_NodeType >(node_type_);
}
inline void NameValueSet::set_node_type(::NameValueSet_NodeType value) {
  GOOGLE_DCHECK(::NameValueSet_NodeType_IsValid(value));
  set_has_node_type();
  node_type_ = value;
}

// optional string name = 2;
inline bool NameValueSet::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameValueSet::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameValueSet::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameValueSet::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameValueSet::name() const {
  return *name_;
}
inline void NameValueSet::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameValueSet::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameValueSet::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameValueSet::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameValueSet::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string value = 3;
inline bool NameValueSet::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameValueSet::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameValueSet::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameValueSet::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& NameValueSet::value() const {
  return *value_;
}
inline void NameValueSet::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameValueSet::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void NameValueSet::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameValueSet::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* NameValueSet::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .NameValueSet node = 4;
inline int NameValueSet::node_size() const {
  return node_.size();
}
inline void NameValueSet::clear_node() {
  node_.Clear();
}
inline const ::NameValueSet& NameValueSet::node(int index) const {
  return node_.Get(index);
}
inline ::NameValueSet* NameValueSet::mutable_node(int index) {
  return node_.Mutable(index);
}
inline ::NameValueSet* NameValueSet::add_node() {
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
NameValueSet::node() const {
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
NameValueSet::mutable_node() {
  return &node_;
}

// -------------------------------------------------------------------

// Document

// required string name_space = 1;
inline bool Document::has_name_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Document::set_has_name_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Document::clear_has_name_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Document::clear_name_space() {
  if (name_space_ != &::google::protobuf::internal::kEmptyString) {
    name_space_->clear();
  }
  clear_has_name_space();
}
inline const ::std::string& Document::name_space() const {
  return *name_space_;
}
inline void Document::set_name_space(const ::std::string& value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
}
inline void Document::set_name_space(const char* value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
}
inline void Document::set_name_space(const char* value, size_t size) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_name_space() {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    name_space_ = new ::std::string;
  }
  return name_space_;
}
inline ::std::string* Document::release_name_space() {
  clear_has_name_space();
  if (name_space_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_space_;
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 id = 2;
inline bool Document::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Document::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Document::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Document::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 Document::id() const {
  return id_;
}
inline void Document::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required bytes img_byte = 3;
inline bool Document::has_img_byte() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Document::set_has_img_byte() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Document::clear_has_img_byte() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Document::clear_img_byte() {
  if (img_byte_ != &::google::protobuf::internal::kEmptyString) {
    img_byte_->clear();
  }
  clear_has_img_byte();
}
inline const ::std::string& Document::img_byte() const {
  return *img_byte_;
}
inline void Document::set_img_byte(const ::std::string& value) {
  set_has_img_byte();
  if (img_byte_ == &::google::protobuf::internal::kEmptyString) {
    img_byte_ = new ::std::string;
  }
  img_byte_->assign(value);
}
inline void Document::set_img_byte(const char* value) {
  set_has_img_byte();
  if (img_byte_ == &::google::protobuf::internal::kEmptyString) {
    img_byte_ = new ::std::string;
  }
  img_byte_->assign(value);
}
inline void Document::set_img_byte(const void* value, size_t size) {
  set_has_img_byte();
  if (img_byte_ == &::google::protobuf::internal::kEmptyString) {
    img_byte_ = new ::std::string;
  }
  img_byte_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_img_byte() {
  set_has_img_byte();
  if (img_byte_ == &::google::protobuf::internal::kEmptyString) {
    img_byte_ = new ::std::string;
  }
  return img_byte_;
}
inline ::std::string* Document::release_img_byte() {
  clear_has_img_byte();
  if (img_byte_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = img_byte_;
    img_byte_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .Point location = 4;
inline bool Document::has_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Document::set_has_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Document::clear_has_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Document::clear_location() {
  if (location_ != NULL) location_->::Point::Clear();
  clear_has_location();
}
inline const ::Point& Document::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::Point* Document::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::Point;
  return location_;
}
inline ::Point* Document::release_location() {
  clear_has_location();
  ::Point* temp = location_;
  location_ = NULL;
  return temp;
}

// optional string file_name = 5;
inline bool Document::has_file_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Document::set_has_file_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Document::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Document::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& Document::file_name() const {
  return *file_name_;
}
inline void Document::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void Document::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void Document::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* Document::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string file_type = 6;
inline bool Document::has_file_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Document::set_has_file_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Document::clear_has_file_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Document::clear_file_type() {
  if (file_type_ != &::google::protobuf::internal::kEmptyString) {
    file_type_->clear();
  }
  clear_has_file_type();
}
inline const ::std::string& Document::file_type() const {
  return *file_type_;
}
inline void Document::set_file_type(const ::std::string& value) {
  set_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    file_type_ = new ::std::string;
  }
  file_type_->assign(value);
}
inline void Document::set_file_type(const char* value) {
  set_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    file_type_ = new ::std::string;
  }
  file_type_->assign(value);
}
inline void Document::set_file_type(const char* value, size_t size) {
  set_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    file_type_ = new ::std::string;
  }
  file_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Document::mutable_file_type() {
  set_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    file_type_ = new ::std::string;
  }
  return file_type_;
}
inline ::std::string* Document::release_file_type() {
  clear_has_file_type();
  if (file_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_type_;
    file_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 time = 7;
inline bool Document::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Document::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Document::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Document::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Document::time() const {
  return time_;
}
inline void Document::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// Header

// required .Header.Routing routing_id = 2;
inline bool Header::has_routing_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_routing_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_routing_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_routing_id() {
  routing_id_ = 2;
  clear_has_routing_id();
}
inline ::Header_Routing Header::routing_id() const {
  return static_cast< ::Header_Routing >(routing_id_);
}
inline void Header::set_routing_id(::Header_Routing value) {
  GOOGLE_DCHECK(::Header_Routing_IsValid(value));
  set_has_routing_id();
  routing_id_ = value;
}

// required string originator = 3;
inline bool Header::has_originator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_originator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_originator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_originator() {
  if (originator_ != &::google::protobuf::internal::kEmptyString) {
    originator_->clear();
  }
  clear_has_originator();
}
inline const ::std::string& Header::originator() const {
  return *originator_;
}
inline void Header::set_originator(const ::std::string& value) {
  set_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    originator_ = new ::std::string;
  }
  originator_->assign(value);
}
inline void Header::set_originator(const char* value) {
  set_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    originator_ = new ::std::string;
  }
  originator_->assign(value);
}
inline void Header::set_originator(const char* value, size_t size) {
  set_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    originator_ = new ::std::string;
  }
  originator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_originator() {
  set_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    originator_ = new ::std::string;
  }
  return originator_;
}
inline ::std::string* Header::release_originator() {
  clear_has_originator();
  if (originator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = originator_;
    originator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string tag = 4;
inline bool Header::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Header::tag() const {
  return *tag_;
}
inline void Header::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Header::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Header::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* Header::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Header.ReplyStatus reply_code = 5;
inline bool Header::has_reply_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_reply_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_reply_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_reply_code() {
  reply_code_ = 1;
  clear_has_reply_code();
}
inline ::Header_ReplyStatus Header::reply_code() const {
  return static_cast< ::Header_ReplyStatus >(reply_code_);
}
inline void Header::set_reply_code(::Header_ReplyStatus value) {
  GOOGLE_DCHECK(::Header_ReplyStatus_IsValid(value));
  set_has_reply_code();
  reply_code_ = value;
}

// optional string reply_msg = 6;
inline bool Header::has_reply_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_reply_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_reply_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_reply_msg() {
  if (reply_msg_ != &::google::protobuf::internal::kEmptyString) {
    reply_msg_->clear();
  }
  clear_has_reply_msg();
}
inline const ::std::string& Header::reply_msg() const {
  return *reply_msg_;
}
inline void Header::set_reply_msg(const ::std::string& value) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(value);
}
inline void Header::set_reply_msg(const char* value) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(value);
}
inline void Header::set_reply_msg(const char* value, size_t size) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_reply_msg() {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    reply_msg_ = new ::std::string;
  }
  return reply_msg_;
}
inline ::std::string* Header::release_reply_msg() {
  clear_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reply_msg_;
    reply_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Payload

// optional .Finger finger = 1;
inline bool Payload::has_finger() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Payload::set_has_finger() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Payload::clear_has_finger() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Payload::clear_finger() {
  if (finger_ != NULL) finger_->::Finger::Clear();
  clear_has_finger();
}
inline const ::Finger& Payload::finger() const {
  return finger_ != NULL ? *finger_ : *default_instance_->finger_;
}
inline ::Finger* Payload::mutable_finger() {
  set_has_finger();
  if (finger_ == NULL) finger_ = new ::Finger;
  return finger_;
}
inline ::Finger* Payload::release_finger() {
  clear_has_finger();
  ::Finger* temp = finger_;
  finger_ = NULL;
  return temp;
}

// optional .Document doc = 2;
inline bool Payload::has_doc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Payload::set_has_doc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Payload::clear_has_doc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Payload::clear_doc() {
  if (doc_ != NULL) doc_->::Document::Clear();
  clear_has_doc();
}
inline const ::Document& Payload::doc() const {
  return doc_ != NULL ? *doc_ : *default_instance_->doc_;
}
inline ::Document* Payload::mutable_doc() {
  set_has_doc();
  if (doc_ == NULL) doc_ = new ::Document;
  return doc_;
}
inline ::Document* Payload::release_doc() {
  clear_has_doc();
  ::Document* temp = doc_;
  doc_ = NULL;
  return temp;
}

// optional .NameSpace space = 3;
inline bool Payload::has_space() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Payload::set_has_space() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Payload::clear_has_space() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Payload::clear_space() {
  if (space_ != NULL) space_->::NameSpace::Clear();
  clear_has_space();
}
inline const ::NameSpace& Payload::space() const {
  return space_ != NULL ? *space_ : *default_instance_->space_;
}
inline ::NameSpace* Payload::mutable_space() {
  set_has_space();
  if (space_ == NULL) space_ = new ::NameSpace;
  return space_;
}
inline ::NameSpace* Payload::release_space() {
  clear_has_space();
  ::NameSpace* temp = space_;
  space_ = NULL;
  return temp;
}

// optional .QueryDocument query = 4;
inline bool Payload::has_query() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Payload::set_has_query() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Payload::clear_has_query() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Payload::clear_query() {
  if (query_ != NULL) query_->::QueryDocument::Clear();
  clear_has_query();
}
inline const ::QueryDocument& Payload::query() const {
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::QueryDocument* Payload::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::QueryDocument;
  return query_;
}
inline ::QueryDocument* Payload::release_query() {
  clear_has_query();
  ::QueryDocument* temp = query_;
  query_ = NULL;
  return temp;
}

// optional .ManipulateNS queryUser = 5;
inline bool Payload::has_queryuser() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Payload::set_has_queryuser() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Payload::clear_has_queryuser() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Payload::clear_queryuser() {
  if (queryuser_ != NULL) queryuser_->::ManipulateNS::Clear();
  clear_has_queryuser();
}
inline const ::ManipulateNS& Payload::queryuser() const {
  return queryuser_ != NULL ? *queryuser_ : *default_instance_->queryuser_;
}
inline ::ManipulateNS* Payload::mutable_queryuser() {
  set_has_queryuser();
  if (queryuser_ == NULL) queryuser_ = new ::ManipulateNS;
  return queryuser_;
}
inline ::ManipulateNS* Payload::release_queryuser() {
  clear_has_queryuser();
  ::ManipulateNS* temp = queryuser_;
  queryuser_ = NULL;
  return temp;
}

// optional .LoginInfo login = 6;
inline bool Payload::has_login() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Payload::set_has_login() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Payload::clear_has_login() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Payload::clear_login() {
  if (login_ != NULL) login_->::LoginInfo::Clear();
  clear_has_login();
}
inline const ::LoginInfo& Payload::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::LoginInfo* Payload::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::LoginInfo;
  return login_;
}
inline ::LoginInfo* Payload::release_login() {
  clear_has_login();
  ::LoginInfo* temp = login_;
  login_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PayloadReply

// repeated .Document docs = 1;
inline int PayloadReply::docs_size() const {
  return docs_.size();
}
inline void PayloadReply::clear_docs() {
  docs_.Clear();
}
inline const ::Document& PayloadReply::docs(int index) const {
  return docs_.Get(index);
}
inline ::Document* PayloadReply::mutable_docs(int index) {
  return docs_.Mutable(index);
}
inline ::Document* PayloadReply::add_docs() {
  return docs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Document >&
PayloadReply::docs() const {
  return docs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Document >*
PayloadReply::mutable_docs() {
  return &docs_;
}

// repeated .NameSpace spaces = 2;
inline int PayloadReply::spaces_size() const {
  return spaces_.size();
}
inline void PayloadReply::clear_spaces() {
  spaces_.Clear();
}
inline const ::NameSpace& PayloadReply::spaces(int index) const {
  return spaces_.Get(index);
}
inline ::NameSpace* PayloadReply::mutable_spaces(int index) {
  return spaces_.Mutable(index);
}
inline ::NameSpace* PayloadReply::add_spaces() {
  return spaces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NameSpace >&
PayloadReply::spaces() const {
  return spaces_;
}
inline ::google::protobuf::RepeatedPtrField< ::NameSpace >*
PayloadReply::mutable_spaces() {
  return &spaces_;
}

// optional .Document stats = 3;
inline bool PayloadReply::has_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayloadReply::set_has_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayloadReply::clear_has_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayloadReply::clear_stats() {
  if (stats_ != NULL) stats_->::Document::Clear();
  clear_has_stats();
}
inline const ::Document& PayloadReply::stats() const {
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::Document* PayloadReply::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::Document;
  return stats_;
}
inline ::Document* PayloadReply::release_stats() {
  clear_has_stats();
  ::Document* temp = stats_;
  stats_ = NULL;
  return temp;
}

// optional .Document finger = 4;
inline bool PayloadReply::has_finger() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayloadReply::set_has_finger() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayloadReply::clear_has_finger() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayloadReply::clear_finger() {
  if (finger_ != NULL) finger_->::Document::Clear();
  clear_has_finger();
}
inline const ::Document& PayloadReply::finger() const {
  return finger_ != NULL ? *finger_ : *default_instance_->finger_;
}
inline ::Document* PayloadReply::mutable_finger() {
  set_has_finger();
  if (finger_ == NULL) finger_ = new ::Document;
  return finger_;
}
inline ::Document* PayloadReply::release_finger() {
  clear_has_finger();
  ::Document* temp = finger_;
  finger_ = NULL;
  return temp;
}

// optional string uuid = 5;
inline bool PayloadReply::has_uuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PayloadReply::set_has_uuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PayloadReply::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PayloadReply::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& PayloadReply::uuid() const {
  return *uuid_;
}
inline void PayloadReply::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void PayloadReply::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void PayloadReply::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayloadReply::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* PayloadReply::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Request

// required .Header header = 1;
inline bool Request::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_header() {
  if (header_ != NULL) header_->::Header::Clear();
  clear_has_header();
}
inline const ::Header& Request::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Header* Request::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Header;
  return header_;
}
inline ::Header* Request::release_header() {
  clear_has_header();
  ::Header* temp = header_;
  header_ = NULL;
  return temp;
}

// required .Payload body = 2;
inline bool Request::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_body() {
  if (body_ != NULL) body_->::Payload::Clear();
  clear_has_body();
}
inline const ::Payload& Request::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::Payload* Request::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::Payload;
  return body_;
}
inline ::Payload* Request::release_body() {
  clear_has_body();
  ::Payload* temp = body_;
  body_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Response

// required .Header header = 1;
inline bool Response::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_header() {
  if (header_ != NULL) header_->::Header::Clear();
  clear_has_header();
}
inline const ::Header& Response::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Header* Response::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Header;
  return header_;
}
inline ::Header* Response::release_header() {
  clear_has_header();
  ::Header* temp = header_;
  header_ = NULL;
  return temp;
}

// optional .PayloadReply body = 2;
inline bool Response::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_body() {
  if (body_ != NULL) body_->::PayloadReply::Clear();
  clear_has_body();
}
inline const ::PayloadReply& Response::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::PayloadReply* Response::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::PayloadReply;
  return body_;
}
inline ::PayloadReply* Response::release_body() {
  clear_has_body();
  ::PayloadReply* temp = body_;
  body_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Heartbeat

// required string nodeId = 1;
inline bool Heartbeat::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Heartbeat::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Heartbeat::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Heartbeat::clear_nodeid() {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    nodeid_->clear();
  }
  clear_has_nodeid();
}
inline const ::std::string& Heartbeat::nodeid() const {
  return *nodeid_;
}
inline void Heartbeat::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Heartbeat::set_nodeid(const char* value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Heartbeat::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Heartbeat::mutable_nodeid() {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  return nodeid_;
}
inline ::std::string* Heartbeat::release_nodeid() {
  clear_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeid_;
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 timeRef = 2;
inline bool Heartbeat::has_timeref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Heartbeat::set_has_timeref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Heartbeat::clear_has_timeref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Heartbeat::clear_timeref() {
  timeref_ = GOOGLE_LONGLONG(0);
  clear_has_timeref();
}
inline ::google::protobuf::int64 Heartbeat::timeref() const {
  return timeref_;
}
inline void Heartbeat::set_timeref(::google::protobuf::int64 value) {
  set_has_timeref();
  timeref_ = value;
}

// -------------------------------------------------------------------

// Network

// required string nodeId = 1;
inline bool Network::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Network::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Network::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Network::clear_nodeid() {
  if (nodeid_ != &::google::protobuf::internal::kEmptyString) {
    nodeid_->clear();
  }
  clear_has_nodeid();
}
inline const ::std::string& Network::nodeid() const {
  return *nodeid_;
}
inline void Network::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Network::set_nodeid(const char* value) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(value);
}
inline void Network::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  nodeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Network::mutable_nodeid() {
  set_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    nodeid_ = new ::std::string;
  }
  return nodeid_;
}
inline ::std::string* Network::release_nodeid() {
  clear_has_nodeid();
  if (nodeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodeid_;
    nodeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .Network.Action action = 2;
inline bool Network::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Network::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Network::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Network::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::Network_Action Network::action() const {
  return static_cast< ::Network_Action >(action_);
}
inline void Network::set_action(::Network_Action value) {
  GOOGLE_DCHECK(::Network_Action_IsValid(value));
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// Management

// optional .Network graph = 1;
inline bool Management::has_graph() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Management::set_has_graph() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Management::clear_has_graph() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Management::clear_graph() {
  if (graph_ != NULL) graph_->::Network::Clear();
  clear_has_graph();
}
inline const ::Network& Management::graph() const {
  return graph_ != NULL ? *graph_ : *default_instance_->graph_;
}
inline ::Network* Management::mutable_graph() {
  set_has_graph();
  if (graph_ == NULL) graph_ = new ::Network;
  return graph_;
}
inline ::Network* Management::release_graph() {
  clear_has_graph();
  ::Network* temp = graph_;
  graph_ = NULL;
  return temp;
}

// optional .Heartbeat beat = 2;
inline bool Management::has_beat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Management::set_has_beat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Management::clear_has_beat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Management::clear_beat() {
  if (beat_ != NULL) beat_->::Heartbeat::Clear();
  clear_has_beat();
}
inline const ::Heartbeat& Management::beat() const {
  return beat_ != NULL ? *beat_ : *default_instance_->beat_;
}
inline ::Heartbeat* Management::mutable_beat() {
  set_has_beat();
  if (beat_ == NULL) beat_ = new ::Heartbeat;
  return beat_;
}
inline ::Heartbeat* Management::release_beat() {
  clear_has_beat();
  ::Heartbeat* temp = beat_;
  beat_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NameValueSet_NodeType>() {
  return ::NameValueSet_NodeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Header_Routing>() {
  return ::Header_Routing_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Header_ReplyStatus>() {
  return ::Header_ReplyStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Network_Action>() {
  return ::Network_Action_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_comm_2eproto__INCLUDED
